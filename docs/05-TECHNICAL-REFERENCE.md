# Technical Reference - Global Marathon Analytics Demo

**Comprehensive Architecture & Implementation Guide**

This document provides detailed technical information about the demo architecture, data model, implementation decisions, and Snowflake features used.

---

## Table of Contents

1. [System Architecture](#system-architecture)
2. [Data Model](#data-model)
3. [Data Generation Strategy](#data-generation-strategy)
4. [Snowflake Features Used](#snowflake-features-used)
5. [Semantic View Design](#semantic-view-design)
6. [Performance Considerations](#performance-considerations)
7. [Security & Governance](#security--governance)
8. [Cost Optimization](#cost-optimization)
9. [Troubleshooting Guide](#troubleshooting-guide)

---

## System Architecture

### High-Level Architecture

```
Data Generation (Native Snowflake)
  ↓
RAW_INGESTION Schema (Landing Zone)
  ↓
STAGING Schema (Cleaned & Typed)
  ↓
ANALYTICS Schema (Business Layer)
  ├─→ Fact Tables
  ├─→ Cortex AI Enrichment
  └─→ Semantic View (MARATHON_INSIGHTS)
        ↓
  Snowflake Intelligence (Natural Language Interface)
```

### Component Layers

#### Layer 1: Raw Ingestion
- **Purpose:** Land synthetic data generated by GENERATOR() functions
- **Schema:** `SNOWFLAKE_EXAMPLE.RAW_INGESTION`
- **Tables:** 6 raw tables (marathons, participants, race_results, sponsors, social_media_posts, broadcast_metrics)
- **Data Format:** Structured tables with minimal transformations
- **Idempotency:** All generation scripts use CREATE OR REPLACE

#### Layer 2: Staging
- **Purpose:** Clean, type-cast, and prepare data for analytics
- **Schema:** `SNOWFLAKE_EXAMPLE.STAGING`
- **Objects:** Views (not tables) for minimal storage
- **Transformations:** Data type conversions, NULL handling, basic calculations

#### Layer 3: Analytics
- **Purpose:** Business-ready aggregated data
- **Schema:** `SNOWFLAKE_EXAMPLE.ANALYTICS`
- **Objects:** Materialized tables, Cortex-enriched tables, semantic view
- **Features:** Pre-aggregated metrics, AI-powered insights

#### Layer 4: Semantic Layer
- **Purpose:** Business terminology mapping for natural language
- **Implementation:** CREATE SEMANTIC VIEW (DDL)
- **Format:** Native Snowflake object (not YAML file)
- **Status:** Public Preview (as of April 2025)

---

## Data Model

### Entity Relationship Diagram

```
MARATHONS (6 records)
  ├── marathon_id (PK)
  ├── marathon_name
  ├── city
  ├── country
  ├── typical_date
  ├── elevation_gain_meters
  └── course_difficulty

PARTICIPANTS (50,000+ records)
  ├── participant_id (PK)
  ├── first_name
  ├── last_name
  ├── age
  ├── gender
  ├── country
  ├── experience_level
  └── registration_date

RACE_RESULTS (300,000+ records)
  ├── result_id (PK)
  ├── participant_id (FK → PARTICIPANTS)
  ├── marathon_id (FK → MARATHONS)
  ├── race_year
  ├── finish_time_minutes
  ├── placement_overall
  ├── placement_age_group
  ├── age_group
  └── qualified_for_boston (BOOLEAN)

SPONSORS (30+ records)
  ├── sponsor_id (PK)
  ├── sponsor_name
  ├── industry
  └── sponsorship_tier (Platinum, Gold, Silver)

SPONSOR_CONTRACTS (relationship table)
  ├── contract_id (PK)
  ├── sponsor_id (FK → SPONSORS)
  ├── marathon_id (FK → MARATHONS)
  ├── contract_year
  ├── contract_value
  ├── activation_spend
  └── media_exposure_minutes

SOCIAL_MEDIA_POSTS (10,000+ records)
  ├── post_id (PK)
  ├── marathon_id (FK → MARATHONS)
  ├── post_date
  ├── post_text
  ├── engagement_count (likes + shares)
  └── platform (Twitter, Instagram, Facebook)

BROADCAST_METRICS (18 records - 3 years × 6 marathons)
  ├── broadcast_id (PK)
  ├── marathon_id (FK → MARATHONS)
  ├── broadcast_year
  ├── total_viewership
  ├── avg_concurrent_viewers
  ├── broadcast_duration_minutes
  └── regions (ARRAY of countries)
```

### Key Relationships

- **One-to-Many:** MARATHONS → RACE_RESULTS (one marathon, many results)
- **Many-to-One:** RACE_RESULTS → PARTICIPANTS (many results per participant over years)
- **Many-to-Many:** MARATHONS ↔ SPONSORS (via SPONSOR_CONTRACTS)
- **One-to-Many:** MARATHONS → SOCIAL_MEDIA_POSTS
- **One-to-Many:** MARATHONS → BROADCAST_METRICS

---

## Data Generation Strategy

### Why 100% Native Snowflake?

**Decision:** Use Snowflake's GENERATOR() function instead of external data generators (Python Faker, etc.)

**Rationale:**
1. **No external dependencies:** Demo works in any Snowflake account
2. **Performance:** GENERATOR() is highly optimized for bulk inserts
3. **Repeatability:** RANDOM() with seeds produces consistent data
4. **Simplicity:** Single SQL script per table, no Python/environment setup
5. **Demonstration value:** Shows Snowflake's native capabilities

### Data Generation Techniques

#### Technique 1: GENERATOR() Table Function

```sql
SELECT 
  column1,
  column2
FROM TABLE(GENERATOR(ROWCOUNT => 50000))
```

**Purpose:** Generate N rows in bulk  
**Used for:** Participants, race results, social media posts  
**Performance:** Can generate millions of rows per second

#### Technique 2: UNIFORM() for Numeric Distributions

```sql
SELECT 
  UNIFORM(18, 75, RANDOM(42)) AS age,  -- Age between 18-75
  UNIFORM(180, 300, RANDOM(43)) AS finish_time_minutes  -- 3-5 hour finish times
FROM TABLE(GENERATOR(ROWCOUNT => 50000))
```

**Purpose:** Random numeric values within a range  
**Parameters:** (min, max, random_seed)  
**Used for:** Ages, times, dollar amounts, counts

#### Technique 3: RANDOM() with Seeds

```sql
SELECT 
  CASE MOD(RANDOM(100), 3)
    WHEN 0 THEN 'Male'
    WHEN 1 THEN 'Female'
    ELSE 'Non-binary'
  END AS gender
FROM TABLE(GENERATOR(ROWCOUNT => 50000))
```

**Purpose:** Random categorical data  
**Seed parameter:** Ensures reproducibility (same seed = same data)  
**Used for:** Gender, country, experience level, platform

#### Technique 4: SEQ8() for Unique IDs

```sql
SELECT 
  SEQ8() AS participant_id,  -- Auto-incrementing sequence
  first_name,
  last_name
FROM TABLE(GENERATOR(ROWCOUNT => 50000))
```

**Purpose:** Unique sequential identifiers  
**Alternative:** UUIDs (UUID_STRING()), but SEQ8() is simpler

#### Technique 5: Array Construction for Semi-Structured Data

```sql
SELECT 
  marathon_id,
  ARRAY_CONSTRUCT('USA', 'Canada', 'UK', 'Japan') AS broadcast_regions
FROM RAW_INGESTION.MARATHONS
```

**Purpose:** Semi-structured data (ARRAY, OBJECT types)  
**Used for:** Broadcast regions, sponsor categories

### Data Volume Strategy

| Table | Row Count | Reasoning |
|-------|-----------|-----------|
| MARATHONS | 6 | Real number of major marathons |
| PARTICIPANTS | 50,000 | Representative sample (real total: ~300K) |
| RACE_RESULTS | 300,000 | 6 marathons × 50K participants × 3 years ÷ 3 (not everyone runs every year) |
| SPONSORS | 30 | Realistic sponsor count across all marathons |
| SPONSOR_CONTRACTS | 60 | ~10 sponsors per marathon |
| SOCIAL_MEDIA_POSTS | 10,000 | High-engagement subset |
| BROADCAST_METRICS | 18 | 6 marathons × 3 years |

**Total Data Size:** ~50 MB (compressed in Snowflake)

---

## Snowflake Features Used

### Cortex AI Functions

#### SENTIMENT()

**Purpose:** Analyze emotional tone of text  
**Syntax:** `SNOWFLAKE.CORTEX.SENTIMENT(text_column)`  
**Output:** Score from -1.0 (negative) to 1.0 (positive)  
**Use Case:** Analyze fan social media posts

**Example:**
```sql
SELECT 
  post_text,
  SNOWFLAKE.CORTEX.SENTIMENT(post_text) AS sentiment_score
FROM RAW_INGESTION.SOCIAL_MEDIA_POSTS;
```

**Cost:** 0.10 credits per 1M tokens (text input)

#### SUMMARIZE()

**Purpose:** Generate concise summaries of long text  
**Syntax:** `SNOWFLAKE.CORTEX.SUMMARIZE(text_column)`  
**Output:** Shortened text (typically 20-30% of original)  
**Use Case:** Summarize long fan reviews or reports

**Example:**
```sql
SELECT 
  post_text,
  SNOWFLAKE.CORTEX.SUMMARIZE(post_text) AS summary
FROM RAW_INGESTION.SOCIAL_MEDIA_POSTS
WHERE LENGTH(post_text) > 500;
```

**Cost:** 0.10 credits per 1M tokens

### Semantic Views (Public Preview)

**Feature:** CREATE SEMANTIC VIEW  
**Status:** Public Preview (April 2025)  
**Alternative:** YAML semantic models (being deprecated)

**Why DDL over YAML:**
1. **Native objects:** Full RBAC integration
2. **Version control:** Managed via SQL DDL
3. **Discoverability:** `SHOW SEMANTIC VIEWS` works
4. **Future-proof:** Snowflake's strategic direction

**Structure:**
- **Logical Tables:** Business-friendly table names
- **Dimensions:** Filterable, groupable columns
- **Metrics:** Calculated measures (COUNT, AVG, SUM, etc.)
- **Synonyms:** Alternative names for natural language
- **Relationships:** Foreign key connections

### Snowflake Intelligence (Cortex Analyst)

**Feature:** Natural language query interface  
**Status:** Generally Available (GA)  
**Requirements:**
- Semantic view or YAML semantic model
- Snowflake Intelligence enabled in account
- CORTEX_USER database role

**Architecture:**
1. User asks question in natural language
2. Cortex Analyst interprets question using semantic view
3. Generates SQL query
4. Executes query on Snowflake engine
5. Returns results with verification shield

**Pricing:** Included with Snowflake account (no separate cost for queries)

---

## Semantic View Design

### Design Principles

#### Principle 1: Map Business Terminology

**Bad:** Use database column names (e.g., `PTYP_CD`)  
**Good:** Use business terms (e.g., `participant_type`)

#### Principle 2: Include Synonyms

**Example:**
- `marathon_name` with synonyms: ["race name", "event", "marathon"]
- `sponsor_name` with synonyms: ["brand", "partner", "company"]

#### Principle 3: Pre-Calculate Complex Metrics

**Example:**
```sql
metrics: [
  cost_per_minute (expr: SUM(contract_value) / SUM(exposure_minutes))
]
```

This allows: *"What's the title sponsor's cost per minute?"*

#### Principle 4: Use Wide Tables Over Long Tables

**Bad (Long format):**
```
metric_name | value
-----------|------
revenue    | 1000
cost       | 500
```

**Good (Wide format):**
```
revenue | cost
--------|-----
1000    | 500
```

Reason: Intelligence understands columns as metrics

### Semantic View Schema

```sql
CREATE SEMANTIC VIEW MARATHON_INSIGHTS AS (
  -- Logical Table 1: Marathon Performance
  TABLE marathon_performance (
    base_table: ANALYTICS.FCT_MARATHON_PERFORMANCE,
    dimensions: [
      marathon_name (synonyms: ["race", "event"]),
      race_year,
      city,
      country,
      course_difficulty
    ],
    metrics: [
      total_participants (expr: COUNT(DISTINCT participant_id)),
      avg_finish_time (expr: AVG(finish_time_minutes)),
      qualification_rate (expr: SUM(CASE WHEN qualified THEN 1 ELSE 0 END) / COUNT(*))
    ]
  ),
  
  -- Logical Table 2: Sponsor ROI
  TABLE sponsor_roi (
    base_table: ANALYTICS.FCT_SPONSOR_ROI,
    dimensions: [
      sponsor_name (synonyms: ["brand", "partner"]),
      marathon_name,
      sponsorship_tier (synonyms: ["level", "category"]),
      contract_year
    ],
    metrics: [
      total_investment (expr: SUM(contract_value + activation_spend)),
      media_exposure_minutes (expr: SUM(exposure_minutes)),
      cost_per_minute (expr: SUM(contract_value) / SUM(exposure_minutes))
    ]
  ),
  
  -- Logical Table 3: Fan Engagement
  TABLE fan_engagement (
    base_table: ANALYTICS.ENRICHED_SOCIAL_MEDIA,
    dimensions: [
      marathon_name,
      post_date,
      platform,
      sentiment_category (expr: CASE 
        WHEN sentiment_score > 0.5 THEN 'Positive'
        WHEN sentiment_score < -0.5 THEN 'Negative'
        ELSE 'Neutral'
      END)
    ],
    metrics: [
      total_posts (expr: COUNT(*)),
      avg_sentiment (expr: AVG(sentiment_score)),
      total_engagement (expr: SUM(engagement_count))
    ]
  )
);
```

---

## Performance Considerations

### Query Optimization

#### Strategy 1: Minimize Micro-Partition Scans

**Technique:** Cluster tables by frequently filtered columns

```sql
ALTER TABLE RACE_RESULTS CLUSTER BY (race_year, marathon_id);
```

**Benefit:** Queries filtering on `race_year` or `marathon_id` scan fewer partitions

#### Strategy 2: Use Materialized Tables for Analytics

**Instead of:**
```sql
CREATE VIEW ANALYTICS.FCT_MARATHON_PERFORMANCE AS
SELECT ... (complex joins and aggregations)
```

**Use:**
```sql
CREATE TABLE ANALYTICS.FCT_MARATHON_PERFORMANCE AS
SELECT ... (complex joins and aggregations)
```

**Trade-off:** Storage cost vs. query performance (worth it for demo)

#### Strategy 3: Pre-Compute Cortex Enrichment

**Don't:**
```sql
SELECT SNOWFLAKE.CORTEX.SENTIMENT(post_text)
FROM RAW_INGESTION.SOCIAL_MEDIA_POSTS;  -- Computes every query
```

**Do:**
```sql
CREATE TABLE ANALYTICS.ENRICHED_SOCIAL_MEDIA AS
SELECT 
  *,
  SNOWFLAKE.CORTEX.SENTIMENT(post_text) AS sentiment_score
FROM RAW_INGESTION.SOCIAL_MEDIA_POSTS;  -- Compute once, query many times
```

### Warehouse Sizing

**Demo Warehouse:** `SFE_MARATHON_WH` (XSMALL)

**Rationale:**
- Data volume is small (50K participants, 300K results)
- Queries are simple (single table scans, basic joins)
- XSMALL is cost-effective for demos

**Scale Up If:**
- Generating data for 100K+ participants
- Running complex multi-table joins
- Multiple concurrent users querying

**Configuration:**
```sql
AUTO_SUSPEND = 60       -- Suspend after 60 seconds (cost optimization)
AUTO_RESUME = TRUE      -- Auto-start on query
WAREHOUSE_SIZE = 'XSMALL'
```

---

## Security & Governance

### Role-Based Access Control (RBAC)

#### Account-Level Objects

**Warehouse:** `SFE_MARATHON_WH`
- **Owner:** ACCOUNTADMIN
- **Usage Grant:** PUBLIC (for demo accessibility)
- **Production:** Would grant to specific roles only

#### Database-Level Objects

**Database:** `SNOWFLAKE_EXAMPLE`
- **Owner:** ACCOUNTADMIN
- **Usage Grant:** PUBLIC

**Schemas:**
- `RAW_INGESTION`: For data landing
- `STAGING`: For transformation
- `ANALYTICS`: For business users

#### Semantic View Access

```sql
-- Grant usage on semantic view
GRANT USAGE ON SEMANTIC VIEW ANALYTICS.MARATHON_INSIGHTS TO ROLE BUSINESS_ANALYST;

-- Users can query without seeing raw tables
-- Semantic view acts as access control layer
```

### Data Privacy

**No PII in Demo:**
- Participant names are synthetic (generated randomly)
- No real email addresses, phone numbers, or addresses
- Social media posts are fabricated
- All data is clearly marked as "DEMO"

**Production Considerations:**
- Apply Snowflake's MASKING POLICIES for sensitive columns
- Use ROW ACCESS POLICIES for multi-tenant scenarios
- Enable DATA CLASSIFICATION tags

---

## Cost Optimization

### Storage Costs

**Strategy:** Use TRANSIENT tables where Time Travel isn't needed

```sql
CREATE TRANSIENT TABLE RAW_INGESTION.PARTICIPANTS AS ...
```

**Benefit:** No Fail-safe period (7 days), reduces storage cost

**Trade-off:** Data cannot be recovered after Time Travel period expires

### Compute Costs

**Strategy 1:** Aggressive auto-suspend
```sql
AUTO_SUSPEND = 60  -- Suspend after 1 minute of inactivity
```

**Strategy 2:** Right-size warehouse
- XSMALL for demos (2 credits/hour)
- SMALL for prod with <100K rows (4 credits/hour)
- MEDIUM for prod with 100K-1M rows (8 credits/hour)

**Strategy 3:** Avoid SELECT * in production
```sql
-- Bad (expensive)
SELECT * FROM large_table;

-- Good (efficient)
SELECT marathon_name, avg_finish_time FROM analytics_table;
```

### Cortex AI Costs

**Pricing:** ~0.10 credits per 1M tokens

**Optimization:**
- Pre-compute sentiment scores (don't recalculate on every query)
- Store results in `ANALYTICS.ENRICHED_SOCIAL_MEDIA` table
- Only analyze new posts (use incremental pattern)

**Cost Example:**
- 10,000 social media posts
- Average 100 tokens per post = 1M tokens total
- One-time cost: 0.10 credits (~$0.30)
- Ongoing query cost: $0 (already computed)

---

## Troubleshooting Guide

### Issue 1: "CORTEX_USER role not found"

**Symptom:**
```sql
SELECT SNOWFLAKE.CORTEX.SENTIMENT('test');
-- Error: SNOWFLAKE.CORTEX.SENTIMENT does not exist
```

**Solution:**
```sql
USE ROLE ACCOUNTADMIN;
GRANT DATABASE ROLE SNOWFLAKE.CORTEX_USER TO ROLE ACCOUNTADMIN;
```

### Issue 2: Semantic View Creation Fails

**Symptom:**
```sql
CREATE SEMANTIC VIEW ...
-- Error: Unknown command 'CREATE SEMANTIC VIEW'
```

**Cause:** Semantic views are in Public Preview (not all accounts)

**Solution:**
1. Contact Snowflake support to enable preview features
2. Or use YAML semantic models as fallback (see docs)

### Issue 3: Intelligence Returns "I don't have enough information"

**Cause:** Question uses terminology not in semantic view

**Solution:**
1. Add synonyms to semantic view for that term
2. Rephrase question using existing terminology
3. Check semantic view: `DESCRIBE SEMANTIC VIEW MARATHON_INSIGHTS;`

### Issue 4: Slow Query Performance

**Symptom:** Queries take >30 seconds

**Diagnosis:**
```sql
-- Check query profile
SELECT * FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY())
WHERE QUERY_TEXT ILIKE '%MARATHON%'
ORDER BY START_TIME DESC
LIMIT 10;
```

**Solutions:**
- Scale up warehouse: `ALTER WAREHOUSE SFE_MARATHON_WH SET WAREHOUSE_SIZE = 'MEDIUM';`
- Add clustering key: `ALTER TABLE ... CLUSTER BY (...);`
- Pre-aggregate data in ANALYTICS layer

### Issue 5: Data Generation Takes Too Long

**Symptom:** `sql/02_data_generation/*.sql` runs for >10 minutes

**Solutions:**
1. Reduce ROWCOUNT in GENERATOR() calls
2. Use MEDIUM warehouse during generation
3. Generate data in batches (multiple INSERT statements)

---

## Deployment Architecture

### Single-Account Deployment (Demo)

```
Snowflake Account
  ├── SFE_MARATHON_WH (Warehouse)
  └── SNOWFLAKE_EXAMPLE (Database)
      ├── RAW_INGESTION (Schema)
      ├── STAGING (Schema)
      └── ANALYTICS (Schema)
          └── MARATHON_INSIGHTS (Semantic View)
```

### Multi-Environment Deployment (Production)

**Recommendation:** Use separate schemas per environment

```
Snowflake Account
  └── MARATHON_ANALYTICS (Database)
      ├── DEV_RAW (Schema)
      ├── DEV_STAGING (Schema)
      ├── DEV_ANALYTICS (Schema)
      ├── PROD_RAW (Schema)
      ├── PROD_STAGING (Schema)
      └── PROD_ANALYTICS (Schema)
```

**Clone for Dev/Test:**
```sql
CREATE SCHEMA DEV_ANALYTICS CLONE PROD_ANALYTICS;
-- Zero-copy clone, instant, no storage cost initially
```

---

## Appendix: Feature Comparison

### Semantic Models: YAML vs. DDL

| Aspect | YAML (Old) | CREATE SEMANTIC VIEW (New) |
|--------|-----------|---------------------------|
| **Format** | YAML file in stage | Native DDL SQL |
| **Version Control** | Manual (Git) | Snowflake DDL history |
| **RBAC** | Stage-level only | Full Snowflake RBAC |
| **Discoverability** | Manual file browsing | `SHOW SEMANTIC VIEWS` |
| **Management** | Stage uploads | `CREATE/ALTER/DROP` commands |
| **Status** | Being deprecated | Public Preview (Apr 2025) |
| **Recommendation** | Migrate away | Use for new projects |

### Data Generation: Native vs. External

| Aspect | Native Snowflake | External (Python/Faker) |
|--------|-----------------|-------------------------|
| **Dependencies** | None | Python, libraries, environment |
| **Performance** | Very fast (millions/sec) | Slower (thousands/sec) |
| **Repeatability** | RANDOM() seeds | Complex seed management |
| **Deployment** | SQL scripts only | Python + SQL |
| **Maintenance** | Simple | Complex |
| **Recommendation** | **Use for demos** | Use for complex scenarios |

---

## Additional Resources

### Snowflake Documentation

- **Cortex AI Functions:** [https://docs.snowflake.com/en/user-guide/snowflake-cortex/llm-functions](https://docs.snowflake.com/en/user-guide/snowflake-cortex/llm-functions)
- **Semantic Views:** [https://docs.snowflake.com/en/user-guide/semantic-views](https://docs.snowflake.com/en/user-guide/semantic-views)
- **Snowflake Intelligence:** [https://docs.snowflake.com/en/user-guide/snowflake-intelligence](https://docs.snowflake.com/en/user-guide/snowflake-intelligence)
- **GENERATOR():** [https://docs.snowflake.com/en/sql-reference/functions/generator](https://docs.snowflake.com/en/sql-reference/functions/generator)

### Related Demo Files

- **Setup Guide:** `docs/01-SETUP.md`
- **Demo Script:** `docs/02-DEMO-SCRIPT.md`
- **Sample Questions:** `docs/04-SAMPLE-QUESTIONS.md`
- **Architecture Diagrams:** `diagrams/`

---

**Last Updated:** 2025-11-17  
**Version:** 1.0  
**Status:** Reference Implementation

